{
  "permissions": {
    "allow": [
      "Bash(dir:*)",
      "WebFetch(domain:developers.cloudflare.com)",
      "WebFetch(domain:www.shadcn-solid.com)",
      "WebFetch(domain:shadcn-solid.com)",
      "WebFetch(domain:shadcn-solid.vercel.app)",
      "WebFetch(domain:raw.githubusercontent.com)",
      "WebFetch(domain:shadcn.com)",
      "WebFetch(domain:ui.shadcn.com)",
      "WebFetch(domain:gist.github.com)",
      "WebFetch(domain:shadisbaih.medium.com)",
      "WebFetch(domain:manupa.dev)",
      "WebFetch(domain:tweakcn.com)",
      "WebFetch(domain:colors.id)",
      "WebFetch(domain:isaichenko.dev)",
      "WebFetch(domain:www.whois.com)",
      "WebFetch(domain:github.com)",
      "WebFetch(domain:blog.cloudflare.com)",
      "WebFetch(domain:learnmcp.examples.workers.dev)",
      "mcp__mcp-registry__search_mcp_registry",
      "Bash(powershell -Command:*)",
      "WebFetch(domain:webmcp.dev)",
      "Bash(npm install:*)",
      "Bash(npx vitest:*)",
      "Bash(node -e:*)",
      "Bash(/c/Users/Matt/Projects/Buckit/test/index.test.js << 'ENDOFFILE'\n/**\n * Buckit Worker — Full test suite \\(100% coverage\\)\n *\n * Uses @cloudflare/vitest-pool-workers:\n * - SELF.fetch\\(\\) exercises the real Worker with real miniflare bindings\n * - env comes from cloudflare:test for direct KV inspection\n * - Utility functions tested directly via imports\n */\n\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { env, SELF } from 'cloudflare:test';\nimport {\n  escapeHtml,\n  formatDate,\n  formatRelativeTime,\n  getSeason,\n  buildImagePrompt,\n  parseRedditPost,\n  renderHtml,\n} from '../src/index.js';\nimport worker from '../src/index.js';\n\n// ── Utilities ──────────────────────────────────────────────────────────────────\n\ndescribe\\('escapeHtml', \\(\\) => {\n  it\\('escapes & < > \" \\\\'', \\(\\) => {\n    expect\\(escapeHtml\\('&<>\"\\\\''\\)\\).toBe\\('&amp;&lt;&gt;&quot;&#039;'\\);\n  }\\);\n  it\\('passes clean strings unchanged', \\(\\) => {\n    expect\\(escapeHtml\\('hello world'\\)\\).toBe\\('hello world'\\);\n  }\\);\n  it\\('returns empty string for non-string', \\(\\) => {\n    expect\\(escapeHtml\\(null\\)\\).toBe\\(''\\);\n    expect\\(escapeHtml\\(undefined\\)\\).toBe\\(''\\);\n    expect\\(escapeHtml\\(42\\)\\).toBe\\(''\\);\n  }\\);\n}\\);\n\ndescribe\\('formatDate', \\(\\) => {\n  it\\('formats a valid ISO string', \\(\\) => {\n    const result = formatDate\\('2024-11-14T17:00:00.000Z'\\);\n    expect\\(result\\).toContain\\('2024'\\);\n    expect\\(result\\).not.toBe\\('Unknown'\\);\n  }\\);\n  it\\('returns Unknown for null', \\(\\) => {\n    expect\\(formatDate\\(null\\)\\).toBe\\('Unknown'\\);\n  }\\);\n  it\\('returns Unknown for invalid date', \\(\\) => {\n    expect\\(formatDate\\('not-a-date'\\)\\).toBe\\('Unknown'\\);\n  }\\);\n}\\);\n\ndescribe\\('formatRelativeTime', \\(\\) => {\n  it\\('returns \"just now\" for very recent', \\(\\) => {\n    expect\\(formatRelativeTime\\(new Date\\(\\).toISOString\\(\\)\\)\\).toBe\\('just now'\\);\n  }\\);\n  it\\('returns minutes ago', \\(\\) => {\n    expect\\(formatRelativeTime\\(new Date\\(Date.now\\(\\) - 5 * 60000\\).toISOString\\(\\)\\)\\).toBe\\('5 minutes ago'\\);\n  }\\);\n  it\\('returns singular minute', \\(\\) => {\n    expect\\(formatRelativeTime\\(new Date\\(Date.now\\(\\) - 60000\\).toISOString\\(\\)\\)\\).toBe\\('1 minute ago'\\);\n  }\\);\n  it\\('returns hours ago', \\(\\) => {\n    expect\\(formatRelativeTime\\(new Date\\(Date.now\\(\\) - 2 * 3600000\\).toISOString\\(\\)\\)\\).toBe\\('2 hours ago'\\);\n  }\\);\n  it\\('returns singular hour', \\(\\) => {\n    expect\\(formatRelativeTime\\(new Date\\(Date.now\\(\\) - 3600000\\).toISOString\\(\\)\\)\\).toBe\\('1 hour ago'\\);\n  }\\);\n  it\\('returns days ago', \\(\\) => {\n    expect\\(formatRelativeTime\\(new Date\\(Date.now\\(\\) - 3 * 86400000\\).toISOString\\(\\)\\)\\).toBe\\('3 days ago'\\);\n  }\\);\n  it\\('returns empty string for null', \\(\\) => {\n    expect\\(formatRelativeTime\\(null\\)\\).toBe\\(''\\);\n  }\\);\n  it\\('returns empty string for invalid date', \\(\\) => {\n    expect\\(formatRelativeTime\\('bad'\\)\\).toBe\\(''\\);\n  }\\);\n}\\);\n\ndescribe\\('getSeason', \\(\\) => {\n  it\\('winter for December', \\(\\) => expect\\(getSeason\\(new Date\\('2024-12-15T12:00:00Z'\\)\\)\\).toBe\\('winter'\\)\\);\n  it\\('winter for January', \\(\\) => expect\\(getSeason\\(new Date\\('2024-01-10T12:00:00Z'\\)\\)\\).toBe\\('winter'\\)\\);\n  it\\('winter for February', \\(\\) => expect\\(getSeason\\(new Date\\('2024-02-20T12:00:00Z'\\)\\)\\).toBe\\('winter'\\)\\);\n  it\\('spring for March', \\(\\) => expect\\(getSeason\\(new Date\\('2024-03-21T12:00:00Z'\\)\\)\\).toBe\\('spring'\\)\\);\n  it\\('spring for May', \\(\\) => expect\\(getSeason\\(new Date\\('2024-05-01T12:00:00Z'\\)\\)\\).toBe\\('spring'\\)\\);\n  it\\('summer for June', \\(\\) => expect\\(getSeason\\(new Date\\('2024-06-21T12:00:00Z'\\)\\)\\).toBe\\('summer'\\)\\);\n  it\\('summer for August', \\(\\) => expect\\(getSeason\\(new Date\\('2024-08-15T12:00:00Z'\\)\\)\\).toBe\\('summer'\\)\\);\n  it\\('fall for September', \\(\\) => expect\\(getSeason\\(new Date\\('2024-09-01T12:00:00Z'\\)\\)\\).toBe\\('fall'\\)\\);\n  it\\('fall for November', \\(\\) => expect\\(getSeason\\(new Date\\('2024-11-01T12:00:00Z'\\)\\)\\).toBe\\('fall'\\)\\);\n}\\);\n\ndescribe\\('buildImagePrompt', \\(\\) => {\n  it\\('includes UP label', \\(\\) => expect\\(buildImagePrompt\\('up', 'abc', new Date\\('2024-01-15T12:00:00Z'\\)\\)\\).toContain\\('going UP'\\)\\);\n  it\\('includes DOWN label', \\(\\) => expect\\(buildImagePrompt\\('down', 'abc', new Date\\('2024-07-15T12:00:00Z'\\)\\)\\).toContain\\('going DOWN'\\)\\);\n  it\\('winter context in January', \\(\\) => expect\\(buildImagePrompt\\('up', 'abc', new Date\\('2024-01-15T12:00:00Z'\\)\\)\\).toContain\\('winter'\\)\\);\n  it\\('summer context in July', \\(\\) => expect\\(buildImagePrompt\\('up', 'abc', new Date\\('2024-07-15T12:00:00Z'\\)\\)\\).toContain\\('summer'\\)\\);\n  it\\('spring context in April', \\(\\) => expect\\(buildImagePrompt\\('up', 'abc', new Date\\('2024-04-15T12:00:00Z'\\)\\)\\).toContain\\('spring'\\)\\);\n  it\\('fall context in October', \\(\\) => expect\\(buildImagePrompt\\('up', 'abc', new Date\\('2024-10-15T12:00:00Z'\\)\\)\\).toContain\\('fall'\\)\\);\n  it\\('includes seed from postId', \\(\\) => expect\\(buildImagePrompt\\('up', 'abc123xyz', new Date\\('2024-01-15T12:00:00Z'\\)\\)\\).toContain\\('abc123xy'\\)\\);\n  it\\('suffering mood for up', \\(\\) => expect\\(buildImagePrompt\\('up', 'abc', new Date\\('2024-01-15T12:00:00Z'\\)\\)\\).toContain\\('suffering'\\)\\);\n  it\\('celebration mood for down', \\(\\) => expect\\(buildImagePrompt\\('down', 'abc', new Date\\('2024-01-15T12:00:00Z'\\)\\)\\).toContain\\('celebration'\\)\\);\n}\\);\n\n// ── Parser ─────────────────────────────────────────────────────────────────────\n\ndescribe\\('parseRedditPost', \\(\\) => {\n  it\\('detects direction up', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Gas prices going up', selftext: '' }\\).direction\\).toBe\\('up'\\);\n  }\\);\n  it\\('detects direction down', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Gas prices going down', selftext: '' }\\).direction\\).toBe\\('down'\\);\n  }\\);\n  it\\('detects increase keyword', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Prices will increase', selftext: '' }\\).direction\\).toBe\\('up'\\);\n  }\\);\n  it\\('detects decrease keyword', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Prices will decrease', selftext: '' }\\).direction\\).toBe\\('down'\\);\n  }\\);\n  it\\('extracts two prices', \\(\\) => {\n    const r = parseRedditPost\\({ title: 'Gas: $1.659/L → $1.719/L', selftext: '' }\\);\n    expect\\(r.currentPrice\\).toBeCloseTo\\(1.659\\);\n    expect\\(r.predictedPrice\\).toBeCloseTo\\(1.719\\);\n  }\\);\n  it\\('single price treated as predicted', \\(\\) => {\n    const r = parseRedditPost\\({ title: 'Gas up to $1.72/L', selftext: '' }\\);\n    expect\\(r.currentPrice\\).toBeNull\\(\\);\n    expect\\(r.predictedPrice\\).toBeCloseTo\\(1.72\\);\n  }\\);\n  it\\('detects diesel', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Diesel prices going up', selftext: '' }\\).fuelType\\).toBe\\('diesel'\\);\n  }\\);\n  it\\('defaults to gas', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Prices going up', selftext: '' }\\).fuelType\\).toBe\\('gas'\\);\n  }\\);\n  it\\('extracts notes from first paragraph', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Gas up', selftext: 'Fill up tonight.\\\\n\\\\nSecond paragraph.' }\\).notes\\).toBe\\('Fill up tonight.'\\);\n  }\\);\n  it\\('null notes when selftext empty', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Gas up', selftext: '' }\\).notes\\).toBeNull\\(\\);\n  }\\);\n  it\\('truncates notes to 500 chars', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Gas up', selftext: 'a'.repeat\\(600\\) }\\).notes?.length\\).toBe\\(500\\);\n  }\\);\n  it\\('null direction when no keywords', \\(\\) => {\n    expect\\(parseRedditPost\\({ title: 'Weekly thread', selftext: '' }\\).direction\\).toBeNull\\(\\);\n  }\\);\n}\\);\n\n// ── renderHtml ─────────────────────────────────────────────────────────────────\n\ndescribe\\('renderHtml', \\(\\) => {\n  const base = {\n    direction: 'up',\n    predictedPrice: 1.719,\n    currentPrice: 1.659,\n    fuelType: 'gas',\n    notes: 'Fill up tonight.',\n    updated_at: '2024-11-14T17:00:00.000Z',\n  };\n\n  it\\('renders HTML with prediction', \\(\\) => {\n    const html = renderHtml\\({ prediction: base, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).toContain\\('<!DOCTYPE html>'\\);\n    expect\\(html\\).toContain\\('$1.719/L'\\);\n    expect\\(html\\).toContain\\('↑'\\);\n  }\\);\n  it\\('renders empty state when null', \\(\\) => {\n    const html = renderHtml\\({ prediction: null, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).toContain\\('No prediction yet.'\\);\n    expect\\(html\\).toContain\\('–'\\);\n  }\\);\n  it\\('renders down arrow', \\(\\) => {\n    const html = renderHtml\\({ prediction: { ...base, direction: 'down' }, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).toContain\\('↓'\\);\n  }\\);\n  it\\('includes image section when imageKey is set', \\(\\) => {\n    const html = renderHtml\\({ prediction: base, history: [], imageKey: 'images/abc123.png', siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).toContain\\('image-section'\\);\n    expect\\(html\\).toContain\\('abc123.png'\\);\n  }\\);\n  it\\('no image section when imageKey is null', \\(\\) => {\n    const html = renderHtml\\({ prediction: base, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).not.toContain\\('image-section'\\);\n  }\\);\n  it\\('renders history cards', \\(\\) => {\n    const html = renderHtml\\({ prediction: base, history: [base], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).toContain\\('history-card'\\);\n    expect\\(html\\).toContain\\('u/buckit'\\);\n  }\\);\n  it\\('hides history section when empty', \\(\\) => {\n    const html = renderHtml\\({ prediction: base, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).toContain\\('display:none'\\);\n    expect\\(html\\).toContain\\('aria-hidden=\"true\"'\\);\n  }\\);\n  it\\('includes SEO meta tags', \\(\\) => {\n    const html = renderHtml\\({ prediction: base, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).toContain\\('<meta name=\"description\"'\\);\n    expect\\(html\\).toContain\\('og:title'\\);\n    expect\\(html\\).toContain\\('twitter:card'\\);\n  }\\);\n  it\\('includes JSON-LD', \\(\\) => {\n    const html = renderHtml\\({ prediction: base, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).toContain\\('application/ld+json'\\);\n    expect\\(html\\).toContain\\('WebSite'\\);\n    expect\\(html\\).toContain\\('Dataset'\\);\n  }\\);\n  it\\('has main landmark', \\(\\) => {\n    expect\\(renderHtml\\({ prediction: base, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\)\\).toContain\\('<main'\\);\n  }\\);\n  it\\('aria-label for up', \\(\\) => {\n    expect\\(renderHtml\\({ prediction: base, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\)\\).toContain\\('aria-label=\"Price going up\"'\\);\n  }\\);\n  it\\('aria-label for down', \\(\\) => {\n    expect\\(renderHtml\\({ prediction: { ...base, direction: 'down' }, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\)\\).toContain\\('aria-label=\"Price going down\"'\\);\n  }\\);\n  it\\('animations inside prefers-reduced-motion media query', \\(\\) => {\n    const html = renderHtml\\({ prediction: base, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html.match\\(/@media \\\\\\(prefers-reduced-motion: no-preference\\\\\\)\\\\s*\\\\{[\\\\s\\\\S]*?@keyframes/\\)\\).not.toBeNull\\(\\);\n  }\\);\n  it\\('XSS-escapes notes', \\(\\) => {\n    const html = renderHtml\\({ prediction: { ...base, notes: '<script>alert\\(1\\)</script>' }, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\);\n    expect\\(html\\).not.toContain\\('<script>alert\\(1\\)</script>'\\);\n    expect\\(html\\).toContain\\('&lt;script&gt;'\\);\n  }\\);\n  it\\('renders DIESEL badge', \\(\\) => {\n    expect\\(renderHtml\\({ prediction: { ...base, fuelType: 'diesel' }, history: [], imageKey: null, siteUrl: 'https://hfxgas.ca' }\\)\\).toContain\\('DIESEL'\\);\n  }\\);\n  it\\('renders sparkline for multiple prices', \\(\\) => {\n    const h = [\n      { predictedPrice: 1.65, direction: 'up', fuelType: 'gas', updated_at: new Date\\(\\).toISOString\\(\\) },\n      { predictedPrice: 1.70, direction: 'down', fuelType: 'gas', updated_at: new Date\\(\\).toISOString\\(\\) },\n      { predictedPrice: 1.68, direction: 'up', fuelType: 'gas', updated_at: new Date\\(\\).toISOString\\(\\) },\n    ];\n    expect\\(renderHtml\\({ prediction: base, history: h, imageKey: null, siteUrl: 'https://hfxgas.ca' }\\)\\).toContain\\('<polyline'\\);\n  }\\);\n  it\\('no sparkline for single price', \\(\\) => {\n    const h = [{ predictedPrice: 1.65, direction: 'up', fuelType: 'gas', updated_at: new Date\\(\\).toISOString\\(\\) }];\n    expect\\(renderHtml\\({ prediction: base, history: h, imageKey: null, siteUrl: 'https://hfxgas.ca' }\\)\\).not.toContain\\('<polyline'\\);\n  }\\);\n}\\);\n\n// ── Routes via SELF ────────────────────────────────────────────────────────────\n\ndescribe\\('GET /', \\(\\) => {\n  beforeEach\\(async \\(\\) => {\n    await env.PREDICTIONS.delete\\('latest_prediction'\\);\n    await env.PREDICTIONS.delete\\('prediction_history'\\);\n    await env.PREDICTIONS.delete\\('latest_image_key'\\);\n  }\\);\n  it\\('200 HTML', async \\(\\) => {\n    const res = await SELF.fetch\\('https://hfxgas.ca/'\\);\n    expect\\(res.status\\).toBe\\(200\\);\n    expect\\(res.headers.get\\('content-type'\\)\\).toContain\\('text/html'\\);\n  }\\);\n  it\\('cache-control: no-store', async \\(\\) => {\n    expect\\(\\(await SELF.fetch\\('https://hfxgas.ca/'\\)\\).headers.get\\('cache-control'\\)\\).toBe\\('no-store'\\);\n  }\\);\n  it\\('empty state when KV empty', async \\(\\) => {\n    expect\\(await \\(await SELF.fetch\\('https://hfxgas.ca/'\\)\\).text\\(\\)\\).toContain\\('No prediction yet.'\\);\n  }\\);\n  it\\('shows prediction data', async \\(\\) => {\n    await env.PREDICTIONS.put\\('latest_prediction', JSON.stringify\\({ direction: 'up', predictedPrice: 1.72, currentPrice: 1.66, fuelType: 'gas', notes: null, updated_at: new Date\\(\\).toISOString\\(\\) }\\)\\);\n    const html = await \\(await SELF.fetch\\('https://hfxgas.ca/'\\)\\).text\\(\\);\n    expect\\(html\\).toContain\\('$1.720/L'\\);\n    expect\\(html\\).toContain\\('↑'\\);\n  }\\);\n  it\\('shows image section when key is set', async \\(\\) => {\n    await env.PREDICTIONS.put\\('latest_prediction', JSON.stringify\\({ direction: 'up', predictedPrice: 1.72, currentPrice: null, fuelType: 'gas', notes: null, updated_at: new Date\\(\\).toISOString\\(\\) }\\)\\);\n    await env.PREDICTIONS.put\\('latest_image_key', 'images/abc123.png'\\);\n    const html = await \\(await SELF.fetch\\('https://hfxgas.ca/'\\)\\).text\\(\\);\n    expect\\(html\\).toContain\\('image-section'\\);\n    expect\\(html\\).toContain\\('abc123.png'\\);\n  }\\);\n  it\\('hides history section when empty', async \\(\\) => {\n    expect\\(await \\(await SELF.fetch\\('https://hfxgas.ca/'\\)\\).text\\(\\)\\).toContain\\('display:none'\\);\n  }\\);\n}\\);\n\ndescribe\\('GET /api/latest', \\(\\) => {\n  beforeEach\\(async \\(\\) => { await env.PREDICTIONS.delete\\('latest_prediction'\\); }\\);\n  it\\('returns null when empty', async \\(\\) => {\n    expect\\(await \\(await SELF.fetch\\('https://hfxgas.ca/api/latest'\\)\\).json\\(\\)\\).toBeNull\\(\\);\n  }\\);\n  it\\('returns prediction', async \\(\\) => {\n    const pred = { direction: 'down', predictedPrice: 1.55, fuelType: 'gas', updated_at: new Date\\(\\).toISOString\\(\\) };\n    await env.PREDICTIONS.put\\('latest_prediction', JSON.stringify\\(pred\\)\\);\n    const data = await \\(await SELF.fetch\\('https://hfxgas.ca/api/latest'\\)\\).json\\(\\);\n    expect\\(data.direction\\).toBe\\('down'\\);\n  }\\);\n}\\);\n\ndescribe\\('GET /robots.txt', \\(\\) => {\n  it\\('200 text/plain allowing all crawlers', async \\(\\) => {\n    const res = await SELF.fetch\\('https://hfxgas.ca/robots.txt'\\);\n    expect\\(res.status\\).toBe\\(200\\);\n    const text = await res.text\\(\\);\n    expect\\(text\\).toContain\\('User-agent: *'\\);\n    expect\\(text\\).toContain\\('Allow: /'\\);\n    expect\\(text\\).toContain\\('Sitemap:'\\);\n  }\\);\n}\\);\n\ndescribe\\('GET /sitemap.xml', \\(\\) => {\n  it\\('200 valid XML', async \\(\\) => {\n    const res = await SELF.fetch\\('https://hfxgas.ca/sitemap.xml'\\);\n    expect\\(res.status\\).toBe\\(200\\);\n    const text = await res.text\\(\\);\n    expect\\(text\\).toContain\\('<urlset'\\);\n    expect\\(text\\).toContain\\('hfxgas.ca'\\);\n  }\\);\n}\\);\n\ndescribe\\('GET /llms.txt', \\(\\) => {\n  it\\('200 text/plain with attribution', async \\(\\) => {\n    const res = await SELF.fetch\\('https://hfxgas.ca/llms.txt'\\);\n    expect\\(res.status\\).toBe\\(200\\);\n    const text = await res.text\\(\\);\n    expect\\(text\\).toContain\\('u/buckit'\\);\n    expect\\(text\\).toContain\\('r/halifax'\\);\n    expect\\(text\\).toContain\\('program-the-brain-not-the-heartbeat'\\);\n  }\\);\n}\\);\n\ndescribe\\('GET /images/:key', \\(\\) => {\n  it\\('returns 404 when image not in R2', async \\(\\) => {\n    expect\\(\\(await SELF.fetch\\('https://hfxgas.ca/images/notfound.png'\\)\\).status\\).toBe\\(404\\);\n  }\\);\n}\\);\n\ndescribe\\('404 routing', \\(\\) => {\n  it\\('unknown GET → 404', async \\(\\) => { expect\\(\\(await SELF.fetch\\('https://hfxgas.ca/unknown'\\)\\).status\\).toBe\\(404\\); }\\);\n  it\\('POST / → 404', async \\(\\) => { expect\\(\\(await SELF.fetch\\('https://hfxgas.ca/', { method: 'POST' }\\)\\).status\\).toBe\\(404\\); }\\);\n  it\\('DELETE /webhook → 404', async \\(\\) => { expect\\(\\(await SELF.fetch\\('https://hfxgas.ca/webhook', { method: 'DELETE' }\\)\\).status\\).toBe\\(404\\); }\\);\n}\\);\n\ndescribe\\('POST /webhook', \\(\\) => {\n  beforeEach\\(async \\(\\) => {\n    await env.PREDICTIONS.delete\\('latest_prediction'\\);\n    await env.PREDICTIONS.delete\\('prediction_history'\\);\n  }\\);\n\n  const valid = { direction: 'up', current_price: 1.659, predicted_price: 1.719, fuel_type: 'gas', notes: 'Fill up.' };\n\n  function req\\(payload, secret, useQuery = false\\) {\n    const url = useQuery ? `https://hfxgas.ca/webhook?secret=${secret}` : 'https://hfxgas.ca/webhook';\n    return new Request\\(url, {\n      method: 'POST',\n      headers: { 'content-type': 'application/json', ...\\(useQuery ? {} : { authorization: `Bearer ${secret}` }\\) },\n      body: JSON.stringify\\(payload\\),\n    }\\);\n  }\n\n  it\\('200 with bearer token', async \\(\\) => { expect\\(\\(await SELF.fetch\\(req\\(valid, 'test-secret'\\)\\)\\).status\\).toBe\\(200\\); }\\);\n  it\\('200 with ?secret= param', async \\(\\) => { expect\\(\\(await SELF.fetch\\(req\\(valid, 'test-secret', true\\)\\)\\).status\\).toBe\\(200\\); }\\);\n  it\\('401 wrong secret', async \\(\\) => { expect\\(\\(await SELF.fetch\\(req\\(valid, 'wrong'\\)\\)\\).status\\).toBe\\(401\\); }\\);\n  it\\('401 no secret', async \\(\\) => {\n    const res = await SELF.fetch\\(new Request\\('https://hfxgas.ca/webhook', { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify\\(valid\\) }\\)\\);\n    expect\\(res.status\\).toBe\\(401\\);\n  }\\);\n  it\\('400 invalid JSON', async \\(\\) => {\n    const res = await SELF.fetch\\(new Request\\('https://hfxgas.ca/webhook', { method: 'POST', headers: { 'content-type': 'application/json', authorization: 'Bearer test-secret' }, body: 'not json' }\\)\\);\n    expect\\(res.status\\).toBe\\(400\\);\n  }\\);\n  it\\('400 invalid direction', async \\(\\) => { expect\\(\\(await SELF.fetch\\(req\\({ ...valid, direction: 'sideways' }, 'test-secret'\\)\\)\\).status\\).toBe\\(400\\); }\\);\n  it\\('400 invalid fuel_type', async \\(\\) => { expect\\(\\(await SELF.fetch\\(req\\({ ...valid, fuel_type: 'jet' }, 'test-secret'\\)\\)\\).status\\).toBe\\(400\\); }\\);\n  it\\('400 non-number predicted_price', async \\(\\) => { expect\\(\\(await SELF.fetch\\(req\\({ ...valid, predicted_price: 'lots' }, 'test-secret'\\)\\)\\).status\\).toBe\\(400\\); }\\);\n  it\\('400 non-number current_price', async \\(\\) => { expect\\(\\(await SELF.fetch\\(req\\({ ...valid, current_price: 'some' }, 'test-secret'\\)\\)\\).status\\).toBe\\(400\\); }\\);\n  it\\('writes to KV with correct shape', async \\(\\) => {\n    await SELF.fetch\\(req\\(valid, 'test-secret'\\)\\);\n    const stored = JSON.parse\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\);\n    expect\\(stored.direction\\).toBe\\('up'\\);\n    expect\\(stored.predictedPrice\\).toBe\\(1.719\\);\n    expect\\(stored.source\\).toBe\\('webhook'\\);\n  }\\);\n  it\\('updated_at is valid ISO 8601', async \\(\\) => {\n    await SELF.fetch\\(req\\(valid, 'test-secret'\\)\\);\n    const stored = JSON.parse\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\);\n    expect\\(new Date\\(stored.updated_at\\).toISOString\\(\\)\\).toBe\\(stored.updated_at\\);\n  }\\);\n  it\\('notes absent → null in KV', async \\(\\) => {\n    const { notes: _, ...noNotes } = valid;\n    await SELF.fetch\\(req\\(noNotes, 'test-secret'\\)\\);\n    expect\\(JSON.parse\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\).notes\\).toBeNull\\(\\);\n  }\\);\n  it\\('fuel_type defaults to gas', async \\(\\) => {\n    const { fuel_type: _, ...noFuel } = valid;\n    await SELF.fetch\\(req\\(noFuel, 'test-secret'\\)\\);\n    expect\\(JSON.parse\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\).fuelType\\).toBe\\('gas'\\);\n  }\\);\n}\\);\n\n// ── Scheduled handler ─────────────────────────────────────────────────────────\n\ndescribe\\('scheduled\\(\\)', \\(\\) => {\n  beforeEach\\(async \\(\\) => {\n    await env.PREDICTIONS.delete\\('latest_prediction'\\);\n    await env.PREDICTIONS.delete\\('prediction_history'\\);\n    await env.PREDICTIONS.delete\\('last_processed_post_id'\\);\n    await env.PREDICTIONS.delete\\('latest_image_key'\\);\n  }\\);\n\n  function mockPost\\(overrides = {}\\) {\n    return {\n      id: 'abc123',\n      author: 'buckit',\n      title: 'Gas prices going up this week - currently $1.659/L, next week $1.719/L',\n      selftext: 'Fill up tonight if you can.',\n      permalink: '/r/halifax/comments/abc123/gas_prices/',\n      created_utc: Math.floor\\(Date.now\\(\\) / 1000\\) - 3600,\n      subreddit: 'halifax',\n      ...overrides,\n    };\n  }\n\n  function envWithAI\\(\\) {\n    return {\n      ...env,\n      AI: { run: vi.fn\\(\\).mockResolvedValue\\({ image: btoa\\('fake-png'\\) }\\) },\n      IMAGES: { get: vi.fn\\(\\).mockResolvedValue\\(null\\), put: vi.fn\\(\\) },\n    };\n  }\n\n  it\\('no-op when no matching post', async \\(\\) => {\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: true, json: async \\(\\) => \\({ data: { children: [] } }\\) }\\);\n    await worker.scheduled\\({}, env, {}\\);\n    expect\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\).toBeNull\\(\\);\n  }\\);\n\n  it\\('no-op for already-processed post \\(dedup\\)', async \\(\\) => {\n    const post = mockPost\\(\\);\n    await env.PREDICTIONS.put\\('last_processed_post_id', post.id\\);\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: true, json: async \\(\\) => \\({ data: { children: [{ data: post }] } }\\) }\\);\n    await worker.scheduled\\({}, env, {}\\);\n    expect\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\).toBeNull\\(\\);\n  }\\);\n\n  it\\('handles Reddit fetch failure gracefully', async \\(\\) => {\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: false, status: 429 }\\);\n    await expect\\(worker.scheduled\\({}, env, {}\\)\\).resolves.not.toThrow\\(\\);\n    expect\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\).toBeNull\\(\\);\n  }\\);\n\n  it\\('processes new /u/buckit post', async \\(\\) => {\n    const post = mockPost\\(\\);\n    const e = envWithAI\\(\\);\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: true, json: async \\(\\) => \\({ data: { children: [{ data: post }] } }\\) }\\);\n    await worker.scheduled\\({}, e, {}\\);\n    const stored = JSON.parse\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\);\n    expect\\(stored.direction\\).toBe\\('up'\\);\n    expect\\(stored.source\\).toBe\\('reddit'\\);\n  }\\);\n\n  it\\('writes last_processed_post_id', async \\(\\) => {\n    const post = mockPost\\(\\);\n    const e = envWithAI\\(\\);\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: true, json: async \\(\\) => \\({ data: { children: [{ data: post }] } }\\) }\\);\n    await worker.scheduled\\({}, e, {}\\);\n    expect\\(await env.PREDICTIONS.get\\('last_processed_post_id'\\)\\).toBe\\(post.id\\);\n  }\\);\n\n  it\\('caps history at MAX_HISTORY', async \\(\\) => {\n    const existing = Array.from\\({ length: 10 }, \\(_, i\\) => \\({ predictedPrice: 1.5 + i * 0.01, direction: 'up', fuelType: 'gas', updated_at: new Date\\(\\).toISOString\\(\\) }\\)\\);\n    await env.PREDICTIONS.put\\('prediction_history', JSON.stringify\\(existing\\)\\);\n    const e = envWithAI\\(\\);\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: true, json: async \\(\\) => \\({ data: { children: [{ data: mockPost\\(\\) }] } }\\) }\\);\n    await worker.scheduled\\({}, e, {}\\);\n    const history = JSON.parse\\(await env.PREDICTIONS.get\\('prediction_history'\\)\\);\n    expect\\(history.length\\).toBe\\(10\\);\n  }\\);\n\n  it\\('no image key when AI returns no image', async \\(\\) => {\n    const post = mockPost\\(\\);\n    const e = { ...env, AI: { run: vi.fn\\(\\).mockResolvedValue\\({ image: null }\\) }, IMAGES: { get: vi.fn\\(\\), put: vi.fn\\(\\) } };\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: true, json: async \\(\\) => \\({ data: { children: [{ data: post }] } }\\) }\\);\n    await worker.scheduled\\({}, e, {}\\);\n    expect\\(await env.PREDICTIONS.get\\('latest_image_key'\\)\\).toBeNull\\(\\);\n  }\\);\n\n  it\\('ignores non-buckit author', async \\(\\) => {\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: true, json: async \\(\\) => \\({ data: { children: [{ data: mockPost\\({ author: 'someoneelse' }\\) }] } }\\) }\\);\n    await worker.scheduled\\({}, env, {}\\);\n    expect\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\).toBeNull\\(\\);\n  }\\);\n\n  it\\('ignores posts older than 24 hours', async \\(\\) => {\n    global.fetch = vi.fn\\(\\).mockResolvedValue\\({ ok: true, json: async \\(\\) => \\({ data: { children: [{ data: mockPost\\({ created_utc: Math.floor\\(Date.now\\(\\) / 1000\\) - 90000 }\\) }] } }\\) }\\);\n    await worker.scheduled\\({}, env, {}\\);\n    expect\\(await env.PREDICTIONS.get\\('latest_prediction'\\)\\).toBeNull\\(\\);\n  }\\);\n}\\);\nENDOFFILE)",
      "Bash(python3:*)",
      "mcp__ef570a1c-e447-49a1-94f9-2fd48bca5d86__accounts_list",
      "mcp__plugin_playwright_playwright__browser_navigate",
      "Bash(npx wrangler deploy)",
      "mcp__plugin_playwright_playwright__browser_take_screenshot",
      "Bash(npx wrangler secret:*)",
      "mcp__plugin_playwright_playwright__browser_resize",
      "WebFetch(domain:www.reddit.com)",
      "Bash(curl:*)",
      "mcp__plugin_playwright_playwright__browser_run_code",
      "Bash(node:*)",
      "mcp__ef570a1c-e447-49a1-94f9-2fd48bca5d86__d1_databases_list",
      "mcp__ef570a1c-e447-49a1-94f9-2fd48bca5d86__kv_namespaces_list",
      "Bash(npx wrangler kv key put:*)",
      "Bash(npx wrangler kv key get:*)",
      "Bash(npx wrangler:*)",
      "Bash(PAYLOAD='{\"\"gas\"\":{\"\"direction\"\":\"\"up\"\",\"\"adjustment\"\":3.6,\"\"price\"\":1.621},\"\"diesel\"\":{\"\"direction\"\":\"\"down\"\",\"\"adjustment\"\":0.7,\"\"price\"\":1.544},\"\"notes\"\":\"\"May be +/- 0.1\"\",\"\"source\"\":\"\"webhook\"\",\"\"updated_at\"\":\"\"2026-02-21T14:30:00.000Z\"\",\"\"post_id\"\":null}')",
      "Bash(\"C:\\\\Users\\\\Matt\\\\Projects\\\\Buckit\\\\AGENTS.md\" << 'ENDOFFILE'\n# AGENTS.md — Buckit\n\nGeneric AI agent context \\(Copilot, Cursor, Gemini, etc.\\).\n\n## Project\n\nBuckit monitors r/halifax for /u/buckit's weekly gas price prediction posts, generates an AI meme image, and serves a display-signage website at hfxgas.ca. Runs on Cloudflare Workers \\(free tier only\\).\n\n## Routes\n\n| Method | Path | Auth | Description |\n|--------|------|------|-------------|\n| GET | / | No | Display website \\(HTML\\) |\n| GET | /api/latest | No | Latest prediction as JSON |\n| GET | /images/:key | No | AI-generated image from R2 |\n| GET | /robots.txt | No | SEO: allow all crawlers |\n| GET | /sitemap.xml | No | SEO: sitemap |\n| GET | /llms.txt | No | GEO: LLM-friendly plain text |\n| POST | /webhook | Yes | Manual prediction override |\n| GET | /mcp | No | MCP server endpoint |\n| * | * | — | 404 |\n\n## Data Model\n\nPredictions use a dual-fuel model. Both `gas` and `diesel` may be `null` if absent from the post:\n\n```json\n{\n  \"gas\":    { \"direction\": \"up|down|no-change|null\", \"adjustment\": 3.6, \"price\": 1.621 },\n  \"diesel\": { \"direction\": \"up|down|no-change|null\", \"adjustment\": 0.7, \"price\": 1.544 },\n  \"notes\": \"optional string\",\n  \"source\": \"reddit|webhook\",\n  \"post_id\": \"1q7msj6\",\n  \"updated_at\": \"2026-02-21T14:00:00.000Z\"\n}\n```\n\n## Webhook Schema\n\n`POST /webhook` with `Authorization: Bearer <WEBHOOK_SECRET>` or `?secret=<WEBHOOK_SECRET>`.\n\n### New format \\(preferred\\)\n\n```json\n{\n  \"gas\":    { \"direction\": \"up|down|no-change\", \"adjustment\": 3.6, \"price\": 1.621 },\n  \"diesel\": { \"direction\": \"up|down|no-change\", \"adjustment\": 0.7, \"price\": 1.544 },\n  \"notes\": \"optional string\"\n}\n```\n\n### Legacy format \\(backward compatible\\)\n\n```json\n{\n  \"direction\": \"up|down|no-change\",\n  \"predicted_price\": 1.72,\n  \"current_price\": 1.66,\n  \"fuel_type\": \"gas|diesel\",\n  \"notes\": \"optional string\"\n}\n```\n\n## Post Format\n\n/u/buckit posts a markdown table in the selftext:\n\n```\n|Type|Adjustment|New Min Price|\n:--|:--|:--|\n|Regular| UP 3.6 |162.1|\n|Diesel| DOWN 0.7 |154.4|\n```\n\nPrices are in **cents** \\(162.1 → $1.621/L\\). `parseAdjustment\\(\\)` handles `UP X.X`, `DOWN X.X`, `NO CHANGE`.\n\n## MCP Tools\n\n| Tool | Auth | Description |\n|------|------|-------------|\n| `get_latest_prediction` | None | Current prediction from KV |\n| `get_prediction_history` | None | Last N predictions \\(max 10\\) |\n| `get_status` | None | Health check: last run, image key, post ID |\n| `post_prediction` | WEBHOOK_SECRET | Submit manual override |\n| `trigger_reddit_scan` | WEBHOOK_SECRET | Trigger Reddit scan manually |\n\n## Cron Schedule \\(Thursday — Halifax time\\)\n\n- `0 12 * * 4` — 12:00 UTC \\(9:00 AM Halifax\\)\n- `0 14 * * 4` — 14:00 UTC \\(11:00 AM Halifax\\)\n- `0 16 * * 4` — 16:00 UTC \\(1:00 PM Halifax\\)\n- `0 18 * * 4` — 18:00 UTC \\(3:00 PM Halifax\\)\n\n**Interrupter clause:** The look-back window is 7 days \\(not 24 hours\\). Posts on any day of the week within the last 7 days are eligible. This handles NSUARB emergency mid-week rate adjustments.\n\n## Storage\n\n**KV \\(PREDICTIONS\\):** `latest_prediction`, `prediction_history`, `latest_image_key`, `last_processed_post_id`\n**R2 \\(IMAGES\\):** `images/{post_id}.png`\n**AI:** `@cf/black-forest-labs/flux-1-schnell` via `env.AI.run\\(\\)` — only called for `up`/`down` directions \\(not `no-change`\\)\n\n## Key Exports \\(src/index.js\\)\n\n| Export | Description |\n|--------|-------------|\n| `escapeHtml\\(str\\)` | XSS-safe HTML escaping |\n| `formatDate\\(iso\\)` | ISO → Halifax local time string |\n| `formatRelativeTime\\(iso\\)` | ISO → \"3 days ago\" |\n| `getSeason\\(date\\)` | UTC date → winter/spring/summer/fall |\n| `buildImagePrompt\\(direction, postId, date\\)` | Weather-aware AI prompt |\n| `parseAdjustment\\(adj\\)` | \"UP 3.6\" → `{direction, adjustment}` |\n| `parseRedditPost\\(post\\)` | Reddit post → `{gas, diesel, notes}` |\n| `buildChartData\\(history\\)` | History array → Chart.js dataset |\n| `renderHtml\\({prediction, history, imageKey, siteUrl}\\)` | Full HTML string |\n\n## Contribution Rules\n\n- PRs must have 100% test coverage \\(enforced via Vitest in CI\\)\n- Tests required for every new route, utility, and MCP tool\n- No secrets in code or commits — use `.dev.vars` locally, Cloudflare secrets in production\n- Conventional Commits format enforced via commitlint\n- Run `task check` before opening a PR\n- Privacy: no personal information anywhere in codebase, comments, or commit messages\n\n## Tech Stack\n\n- **Runtime:** Cloudflare Workers \\(plain JavaScript, no TypeScript, no build step\\)\n- **Storage:** Cloudflare KV + R2\n- **AI:** Cloudflare Workers AI\n- **MCP:** workers-mcp \\(future: webmcp\\)\n- **Testing:** Vitest + @cloudflare/vitest-pool-workers\n- **DX:** Taskfile, ESLint, Prettier, Husky, commitlint\n- **Docs:** VitePress \\(GitHub Pages\\)\n- **CI/CD:** GitHub Actions\nENDOFFILE)",
      "mcp__plugin_playwright_playwright__browser_click",
      "Bash(npx wrangler r2 bucket list:*)",
      "Bash(npx wrangler kv key list:*)",
      "Bash(npx vitest run)",
      "Bash(npx wrangler deploy:*)",
      "Bash(npm audit:*)",
      "mcp__ef570a1c-e447-49a1-94f9-2fd48bca5d86__search_cloudflare_documentation",
      "Bash(xargs sed:*)"
    ]
  }
}
